// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.21.12
// source: websocket.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { TaskRequest, TaskResponse } from "./tasks";

export const protobufPackage = "websocket";

export interface ClientMessage {
  availableTasks?: AvailableTasks | undefined;
  execute?: ExecuteTask | undefined;
  fileResponse?: FileResponse | undefined;
  pause?: Pause | undefined;
  resume?: Resume | undefined;
  handshake?: ClientHandshake | undefined;
}

export interface ServerMessage {
  acceptTask?: AcceptTask | undefined;
  noTaskAvailable?: NoTaskAvailable | undefined;
  taskResult?: TaskResult | undefined;
  incrementalUpdate?: IncrementalUpdate | undefined;
  error?: ErrorResponse | undefined;
  fileRequest?: FileRequest | undefined;
  fileSend?: FileSend | undefined;
  requestAvailableTasks?: RequestAvailableTasks | undefined;
  handshake?: ServerHandshake | undefined;
}

export interface RequestAvailableTasks {
  clientId: string;
}

export interface AvailableTasks {
  tasks: Task[];
}

export interface Task {
  id: string;
  name: string;
  request: TaskRequest | undefined;
}

export interface ExecuteTask {
  taskId: string;
  name: string;
  request: TaskRequest | undefined;
}

export interface Pause {
}

export interface Resume {
}

export interface ClientHandshake {
  version: string;
}

export interface ServerHandshake {
  version: string;
}

export interface AcceptTask {
  taskId: string;
}

export interface NoTaskAvailable {
}

export interface TaskResult {
  taskId: string;
  result: TaskResponse | undefined;
}

export interface IncrementalUpdate {
  taskId: string;
  msg: string;
  update: TaskResponse | undefined;
}

export interface ErrorResponse {
  taskId: string;
  error: string;
}

export interface FileRequest {
  fileId: string;
}

export interface FileResponse {
  fileId: string;
  /** base64 encoded file content */
  content: string;
}

export interface FileSend {
  fileId: string;
  /** base64 encoded file content */
  content: string;
}

function createBaseClientMessage(): ClientMessage {
  return {
    availableTasks: undefined,
    execute: undefined,
    fileResponse: undefined,
    pause: undefined,
    resume: undefined,
    handshake: undefined,
  };
}

export const ClientMessage = {
  encode(message: ClientMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.availableTasks !== undefined) {
      AvailableTasks.encode(message.availableTasks, writer.uint32(10).fork()).ldelim();
    }
    if (message.execute !== undefined) {
      ExecuteTask.encode(message.execute, writer.uint32(18).fork()).ldelim();
    }
    if (message.fileResponse !== undefined) {
      FileResponse.encode(message.fileResponse, writer.uint32(26).fork()).ldelim();
    }
    if (message.pause !== undefined) {
      Pause.encode(message.pause, writer.uint32(34).fork()).ldelim();
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(42).fork()).ldelim();
    }
    if (message.handshake !== undefined) {
      ClientHandshake.encode(message.handshake, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.availableTasks = AvailableTasks.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.execute = ExecuteTask.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileResponse = FileResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pause = Pause.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.handshake = ClientHandshake.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      availableTasks: isSet(object.availableTasks) ? AvailableTasks.fromJSON(object.availableTasks) : undefined,
      execute: isSet(object.execute) ? ExecuteTask.fromJSON(object.execute) : undefined,
      fileResponse: isSet(object.fileResponse) ? FileResponse.fromJSON(object.fileResponse) : undefined,
      pause: isSet(object.pause) ? Pause.fromJSON(object.pause) : undefined,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      handshake: isSet(object.handshake) ? ClientHandshake.fromJSON(object.handshake) : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.availableTasks !== undefined) {
      obj.availableTasks = AvailableTasks.toJSON(message.availableTasks);
    }
    if (message.execute !== undefined) {
      obj.execute = ExecuteTask.toJSON(message.execute);
    }
    if (message.fileResponse !== undefined) {
      obj.fileResponse = FileResponse.toJSON(message.fileResponse);
    }
    if (message.pause !== undefined) {
      obj.pause = Pause.toJSON(message.pause);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.handshake !== undefined) {
      obj.handshake = ClientHandshake.toJSON(message.handshake);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.availableTasks = (object.availableTasks !== undefined && object.availableTasks !== null)
      ? AvailableTasks.fromPartial(object.availableTasks)
      : undefined;
    message.execute = (object.execute !== undefined && object.execute !== null)
      ? ExecuteTask.fromPartial(object.execute)
      : undefined;
    message.fileResponse = (object.fileResponse !== undefined && object.fileResponse !== null)
      ? FileResponse.fromPartial(object.fileResponse)
      : undefined;
    message.pause = (object.pause !== undefined && object.pause !== null) ? Pause.fromPartial(object.pause) : undefined;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.handshake = (object.handshake !== undefined && object.handshake !== null)
      ? ClientHandshake.fromPartial(object.handshake)
      : undefined;
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return {
    acceptTask: undefined,
    noTaskAvailable: undefined,
    taskResult: undefined,
    incrementalUpdate: undefined,
    error: undefined,
    fileRequest: undefined,
    fileSend: undefined,
    requestAvailableTasks: undefined,
    handshake: undefined,
  };
}

export const ServerMessage = {
  encode(message: ServerMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acceptTask !== undefined) {
      AcceptTask.encode(message.acceptTask, writer.uint32(10).fork()).ldelim();
    }
    if (message.noTaskAvailable !== undefined) {
      NoTaskAvailable.encode(message.noTaskAvailable, writer.uint32(18).fork()).ldelim();
    }
    if (message.taskResult !== undefined) {
      TaskResult.encode(message.taskResult, writer.uint32(26).fork()).ldelim();
    }
    if (message.incrementalUpdate !== undefined) {
      IncrementalUpdate.encode(message.incrementalUpdate, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      ErrorResponse.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    if (message.fileRequest !== undefined) {
      FileRequest.encode(message.fileRequest, writer.uint32(50).fork()).ldelim();
    }
    if (message.fileSend !== undefined) {
      FileSend.encode(message.fileSend, writer.uint32(58).fork()).ldelim();
    }
    if (message.requestAvailableTasks !== undefined) {
      RequestAvailableTasks.encode(message.requestAvailableTasks, writer.uint32(66).fork()).ldelim();
    }
    if (message.handshake !== undefined) {
      ServerHandshake.encode(message.handshake, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceptTask = AcceptTask.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.noTaskAvailable = NoTaskAvailable.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskResult = TaskResult.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.incrementalUpdate = IncrementalUpdate.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = ErrorResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fileRequest = FileRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fileSend = FileSend.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.requestAvailableTasks = RequestAvailableTasks.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.handshake = ServerHandshake.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      acceptTask: isSet(object.acceptTask) ? AcceptTask.fromJSON(object.acceptTask) : undefined,
      noTaskAvailable: isSet(object.noTaskAvailable) ? NoTaskAvailable.fromJSON(object.noTaskAvailable) : undefined,
      taskResult: isSet(object.taskResult) ? TaskResult.fromJSON(object.taskResult) : undefined,
      incrementalUpdate: isSet(object.incrementalUpdate)
        ? IncrementalUpdate.fromJSON(object.incrementalUpdate)
        : undefined,
      error: isSet(object.error) ? ErrorResponse.fromJSON(object.error) : undefined,
      fileRequest: isSet(object.fileRequest) ? FileRequest.fromJSON(object.fileRequest) : undefined,
      fileSend: isSet(object.fileSend) ? FileSend.fromJSON(object.fileSend) : undefined,
      requestAvailableTasks: isSet(object.requestAvailableTasks)
        ? RequestAvailableTasks.fromJSON(object.requestAvailableTasks)
        : undefined,
      handshake: isSet(object.handshake) ? ServerHandshake.fromJSON(object.handshake) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.acceptTask !== undefined) {
      obj.acceptTask = AcceptTask.toJSON(message.acceptTask);
    }
    if (message.noTaskAvailable !== undefined) {
      obj.noTaskAvailable = NoTaskAvailable.toJSON(message.noTaskAvailable);
    }
    if (message.taskResult !== undefined) {
      obj.taskResult = TaskResult.toJSON(message.taskResult);
    }
    if (message.incrementalUpdate !== undefined) {
      obj.incrementalUpdate = IncrementalUpdate.toJSON(message.incrementalUpdate);
    }
    if (message.error !== undefined) {
      obj.error = ErrorResponse.toJSON(message.error);
    }
    if (message.fileRequest !== undefined) {
      obj.fileRequest = FileRequest.toJSON(message.fileRequest);
    }
    if (message.fileSend !== undefined) {
      obj.fileSend = FileSend.toJSON(message.fileSend);
    }
    if (message.requestAvailableTasks !== undefined) {
      obj.requestAvailableTasks = RequestAvailableTasks.toJSON(message.requestAvailableTasks);
    }
    if (message.handshake !== undefined) {
      obj.handshake = ServerHandshake.toJSON(message.handshake);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.acceptTask = (object.acceptTask !== undefined && object.acceptTask !== null)
      ? AcceptTask.fromPartial(object.acceptTask)
      : undefined;
    message.noTaskAvailable = (object.noTaskAvailable !== undefined && object.noTaskAvailable !== null)
      ? NoTaskAvailable.fromPartial(object.noTaskAvailable)
      : undefined;
    message.taskResult = (object.taskResult !== undefined && object.taskResult !== null)
      ? TaskResult.fromPartial(object.taskResult)
      : undefined;
    message.incrementalUpdate = (object.incrementalUpdate !== undefined && object.incrementalUpdate !== null)
      ? IncrementalUpdate.fromPartial(object.incrementalUpdate)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorResponse.fromPartial(object.error)
      : undefined;
    message.fileRequest = (object.fileRequest !== undefined && object.fileRequest !== null)
      ? FileRequest.fromPartial(object.fileRequest)
      : undefined;
    message.fileSend = (object.fileSend !== undefined && object.fileSend !== null)
      ? FileSend.fromPartial(object.fileSend)
      : undefined;
    message.requestAvailableTasks =
      (object.requestAvailableTasks !== undefined && object.requestAvailableTasks !== null)
        ? RequestAvailableTasks.fromPartial(object.requestAvailableTasks)
        : undefined;
    message.handshake = (object.handshake !== undefined && object.handshake !== null)
      ? ServerHandshake.fromPartial(object.handshake)
      : undefined;
    return message;
  },
};

function createBaseRequestAvailableTasks(): RequestAvailableTasks {
  return { clientId: "" };
}

export const RequestAvailableTasks = {
  encode(message: RequestAvailableTasks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestAvailableTasks {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestAvailableTasks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestAvailableTasks {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: RequestAvailableTasks): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestAvailableTasks>, I>>(base?: I): RequestAvailableTasks {
    return RequestAvailableTasks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestAvailableTasks>, I>>(object: I): RequestAvailableTasks {
    const message = createBaseRequestAvailableTasks();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseAvailableTasks(): AvailableTasks {
  return { tasks: [] };
}

export const AvailableTasks = {
  encode(message: AvailableTasks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvailableTasks {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableTasks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableTasks {
    return { tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [] };
  },

  toJSON(message: AvailableTasks): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AvailableTasks>, I>>(base?: I): AvailableTasks {
    return AvailableTasks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AvailableTasks>, I>>(object: I): AvailableTasks {
    const message = createBaseAvailableTasks();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTask(): Task {
  return { id: "", name: "", request: undefined };
}

export const Task = {
  encode(message: Task, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.request !== undefined) {
      TaskRequest.encode(message.request, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Task {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.request = TaskRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      request: isSet(object.request) ? TaskRequest.fromJSON(object.request) : undefined,
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.request !== undefined) {
      obj.request = TaskRequest.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.request = (object.request !== undefined && object.request !== null)
      ? TaskRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseExecuteTask(): ExecuteTask {
  return { taskId: "", name: "", request: undefined };
}

export const ExecuteTask = {
  encode(message: ExecuteTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.request !== undefined) {
      TaskRequest.encode(message.request, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.request = TaskRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      request: isSet(object.request) ? TaskRequest.fromJSON(object.request) : undefined,
    };
  },

  toJSON(message: ExecuteTask): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.request !== undefined) {
      obj.request = TaskRequest.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteTask>, I>>(base?: I): ExecuteTask {
    return ExecuteTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteTask>, I>>(object: I): ExecuteTask {
    const message = createBaseExecuteTask();
    message.taskId = object.taskId ?? "";
    message.name = object.name ?? "";
    message.request = (object.request !== undefined && object.request !== null)
      ? TaskRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBasePause(): Pause {
  return {};
}

export const Pause = {
  encode(_: Pause, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pause {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Pause {
    return {};
  },

  toJSON(_: Pause): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Pause>, I>>(base?: I): Pause {
    return Pause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pause>, I>>(_: I): Pause {
    const message = createBasePause();
    return message;
  },
};

function createBaseResume(): Resume {
  return {};
}

export const Resume = {
  encode(_: Resume, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resume {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Resume {
    return {};
  },

  toJSON(_: Resume): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Resume>, I>>(base?: I): Resume {
    return Resume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resume>, I>>(_: I): Resume {
    const message = createBaseResume();
    return message;
  },
};

function createBaseClientHandshake(): ClientHandshake {
  return { version: "" };
}

export const ClientHandshake = {
  encode(message: ClientHandshake, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientHandshake {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientHandshake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientHandshake {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: ClientHandshake): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientHandshake>, I>>(base?: I): ClientHandshake {
    return ClientHandshake.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientHandshake>, I>>(object: I): ClientHandshake {
    const message = createBaseClientHandshake();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseServerHandshake(): ServerHandshake {
  return { version: "" };
}

export const ServerHandshake = {
  encode(message: ServerHandshake, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerHandshake {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerHandshake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerHandshake {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: ServerHandshake): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerHandshake>, I>>(base?: I): ServerHandshake {
    return ServerHandshake.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerHandshake>, I>>(object: I): ServerHandshake {
    const message = createBaseServerHandshake();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseAcceptTask(): AcceptTask {
  return { taskId: "" };
}

export const AcceptTask = {
  encode(message: AcceptTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AcceptTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceptTask {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: AcceptTask): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcceptTask>, I>>(base?: I): AcceptTask {
    return AcceptTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcceptTask>, I>>(object: I): AcceptTask {
    const message = createBaseAcceptTask();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseNoTaskAvailable(): NoTaskAvailable {
  return {};
}

export const NoTaskAvailable = {
  encode(_: NoTaskAvailable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NoTaskAvailable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoTaskAvailable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NoTaskAvailable {
    return {};
  },

  toJSON(_: NoTaskAvailable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NoTaskAvailable>, I>>(base?: I): NoTaskAvailable {
    return NoTaskAvailable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoTaskAvailable>, I>>(_: I): NoTaskAvailable {
    const message = createBaseNoTaskAvailable();
    return message;
  },
};

function createBaseTaskResult(): TaskResult {
  return { taskId: "", result: undefined };
}

export const TaskResult = {
  encode(message: TaskResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.result !== undefined) {
      TaskResponse.encode(message.result, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = TaskResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskResult {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      result: isSet(object.result) ? TaskResponse.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: TaskResult): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.result !== undefined) {
      obj.result = TaskResponse.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskResult>, I>>(base?: I): TaskResult {
    return TaskResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskResult>, I>>(object: I): TaskResult {
    const message = createBaseTaskResult();
    message.taskId = object.taskId ?? "";
    message.result = (object.result !== undefined && object.result !== null)
      ? TaskResponse.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseIncrementalUpdate(): IncrementalUpdate {
  return { taskId: "", msg: "", update: undefined };
}

export const IncrementalUpdate = {
  encode(message: IncrementalUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    if (message.update !== undefined) {
      TaskResponse.encode(message.update, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncrementalUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.update = TaskResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalUpdate {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      update: isSet(object.update) ? TaskResponse.fromJSON(object.update) : undefined,
    };
  },

  toJSON(message: IncrementalUpdate): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.update !== undefined) {
      obj.update = TaskResponse.toJSON(message.update);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncrementalUpdate>, I>>(base?: I): IncrementalUpdate {
    return IncrementalUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncrementalUpdate>, I>>(object: I): IncrementalUpdate {
    const message = createBaseIncrementalUpdate();
    message.taskId = object.taskId ?? "";
    message.msg = object.msg ?? "";
    message.update = (object.update !== undefined && object.update !== null)
      ? TaskResponse.fromPartial(object.update)
      : undefined;
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { taskId: "", error: "" };
}

export const ErrorResponse = {
  encode(message: ErrorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.taskId = object.taskId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseFileRequest(): FileRequest {
  return { fileId: "" };
}

export const FileRequest = {
  encode(message: FileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileRequest {
    return { fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "" };
  },

  toJSON(message: FileRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileRequest>, I>>(base?: I): FileRequest {
    return FileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileRequest>, I>>(object: I): FileRequest {
    const message = createBaseFileRequest();
    message.fileId = object.fileId ?? "";
    return message;
  },
};

function createBaseFileResponse(): FileResponse {
  return { fileId: "", content: "" };
}

export const FileResponse = {
  encode(message: FileResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileResponse {
    return {
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: FileResponse): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileResponse>, I>>(base?: I): FileResponse {
    return FileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileResponse>, I>>(object: I): FileResponse {
    const message = createBaseFileResponse();
    message.fileId = object.fileId ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseFileSend(): FileSend {
  return { fileId: "", content: "" };
}

export const FileSend = {
  encode(message: FileSend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileSend {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSend {
    return {
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: FileSend): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileSend>, I>>(base?: I): FileSend {
    return FileSend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileSend>, I>>(object: I): FileSend {
    const message = createBaseFileSend();
    message.fileId = object.fileId ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
