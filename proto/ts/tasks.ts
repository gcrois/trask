// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: tasks.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { File } from "./definitions";

export const protobufPackage = "";

/**
 * Ignored parameters:
 * send_update: typing.Any
 */
export interface Text2imagedraftRequest {
	prompt: string;
	size: string;
	seed: number;
}

export interface Text2imagedraftResponse {
	result: File | undefined;
}

/**
 * Ignored parameters:
 * send_update: typing.Any
 */
export interface Text2imageRequest {
	prompt: string;
	size: string;
	seed: number;
}

export interface Text2imageResponse {
	result: File | undefined;
}

/**
 * Ignored parameters:
 * send_update: <class 'inspect._empty'>
 */
export interface CapitalizeRequest {
	text: string;
}

export interface CapitalizeResponse {
	result: string;
}

/**
 * Ignored parameters:
 * client: <class 'inspect._empty'>
 * send_update: typing.Callable[[str], typing.Awaitable[typing.Literal['success']]]
 */
export interface Text2textRequest {
	roles: string[];
	messages: string[];
	maxTokens: number;
}

export interface Text2textResponse {
	result: string;
}

/**
 * Ignored parameters:
 * client: <class 'inspect._empty'>
 * send_update: typing.Callable[[str], typing.Awaitable[NoneType]]
 */
export interface Image2captionRequest {
	image: File | undefined;
	tokens: number;
	focus: string;
}

export interface Image2captionResponse {
	result: string;
}

/**
 * Ignored parameters:
 * send_update: typing.Any
 */
export interface Text2audioRequest {
	prompt: string;
	negativePrompt: string;
	duration: number;
	numInferenceSteps: number;
	numWaveforms: number;
	seed: number;
}

export interface Text2audioResponse {
	result: File | undefined;
}

/**
 * Ignored parameters:
 * client: <class 'inspect._empty'>
 * send_update: typing.Callable[[str], typing.Awaitable[NoneType]]
 */
export interface File2textRequest {
	file: File | undefined;
	maxTokens: number;
}

export interface File2textResponse {
	result: string;
}

/**
 * Ignored parameters:
 * send_update: typing.Callable[[str], typing.Awaitable[typing.Literal['success']]]
 */
export interface Text2promptRequest {
	prompt: string;
	maxNewTokens: number;
}

export interface Text2promptResponse {
	result: string;
}

/**
 * Ignored parameters:
 * send_update: typing.Any
 */
export interface TurboeditRequest {
	inputImage: File | undefined;
	srcPrompt: string;
	tgtPrompt: string;
	seed: number;
	w1: number;
}

export interface TurboeditResponse {
	result: File | undefined;
}

/**
 * Ignored parameters:
 * send_update: <class 'inspect._empty'>
 */
export interface Text2imagefileRequest {
	prompt: string;
}

export interface Text2imagefileResponse {
	result: File | undefined;
}

export interface TaskRequest {
	text2imagedraft?: Text2imagedraftRequest | undefined;
	text2image?: Text2imageRequest | undefined;
	capitalize?: CapitalizeRequest | undefined;
	text2text?: Text2textRequest | undefined;
	image2caption?: Image2captionRequest | undefined;
	text2audio?: Text2audioRequest | undefined;
	file2text?: File2textRequest | undefined;
	text2prompt?: Text2promptRequest | undefined;
	turboedit?: TurboeditRequest | undefined;
	text2imagefile?: Text2imagefileRequest | undefined;
}

export interface TaskResponse {
	text2imagedraft?: Text2imagedraftResponse | undefined;
	text2image?: Text2imageResponse | undefined;
	capitalize?: CapitalizeResponse | undefined;
	text2text?: Text2textResponse | undefined;
	image2caption?: Image2captionResponse | undefined;
	text2audio?: Text2audioResponse | undefined;
	file2text?: File2textResponse | undefined;
	text2prompt?: Text2promptResponse | undefined;
	turboedit?: TurboeditResponse | undefined;
	text2imagefile?: Text2imagefileResponse | undefined;
}

function createBaseText2imagedraftRequest(): Text2imagedraftRequest {
	return { prompt: "", size: "", seed: 0 };
}

export const Text2imagedraftRequest = {
	encode(
		message: Text2imagedraftRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		if (message.size !== "") {
			writer.uint32(18).string(message.size);
		}
		if (message.seed !== 0) {
			writer.uint32(24).int32(message.seed);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2imagedraftRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imagedraftRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.size = reader.string();
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.seed = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imagedraftRequest {
		return {
			prompt: isSet(object.prompt)
				? globalThis.String(object.prompt)
				: "",
			size: isSet(object.size) ? globalThis.String(object.size) : "",
			seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
		};
	},

	toJSON(message: Text2imagedraftRequest): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		if (message.size !== "") {
			obj.size = message.size;
		}
		if (message.seed !== 0) {
			obj.seed = Math.round(message.seed);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imagedraftRequest>, I>>(
		base?: I,
	): Text2imagedraftRequest {
		return Text2imagedraftRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imagedraftRequest>, I>>(
		object: I,
	): Text2imagedraftRequest {
		const message = createBaseText2imagedraftRequest();
		message.prompt = object.prompt ?? "";
		message.size = object.size ?? "";
		message.seed = object.seed ?? 0;
		return message;
	},
};

function createBaseText2imagedraftResponse(): Text2imagedraftResponse {
	return { result: undefined };
}

export const Text2imagedraftResponse = {
	encode(
		message: Text2imagedraftResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== undefined) {
			File.encode(message.result, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2imagedraftResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imagedraftResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = File.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imagedraftResponse {
		return {
			result: isSet(object.result)
				? File.fromJSON(object.result)
				: undefined,
		};
	},

	toJSON(message: Text2imagedraftResponse): unknown {
		const obj: any = {};
		if (message.result !== undefined) {
			obj.result = File.toJSON(message.result);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imagedraftResponse>, I>>(
		base?: I,
	): Text2imagedraftResponse {
		return Text2imagedraftResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imagedraftResponse>, I>>(
		object: I,
	): Text2imagedraftResponse {
		const message = createBaseText2imagedraftResponse();
		message.result =
			object.result !== undefined && object.result !== null
				? File.fromPartial(object.result)
				: undefined;
		return message;
	},
};

function createBaseText2imageRequest(): Text2imageRequest {
	return { prompt: "", size: "", seed: 0 };
}

export const Text2imageRequest = {
	encode(
		message: Text2imageRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		if (message.size !== "") {
			writer.uint32(18).string(message.size);
		}
		if (message.seed !== 0) {
			writer.uint32(24).int32(message.seed);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): Text2imageRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imageRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.size = reader.string();
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.seed = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imageRequest {
		return {
			prompt: isSet(object.prompt)
				? globalThis.String(object.prompt)
				: "",
			size: isSet(object.size) ? globalThis.String(object.size) : "",
			seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
		};
	},

	toJSON(message: Text2imageRequest): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		if (message.size !== "") {
			obj.size = message.size;
		}
		if (message.seed !== 0) {
			obj.seed = Math.round(message.seed);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imageRequest>, I>>(
		base?: I,
	): Text2imageRequest {
		return Text2imageRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imageRequest>, I>>(
		object: I,
	): Text2imageRequest {
		const message = createBaseText2imageRequest();
		message.prompt = object.prompt ?? "";
		message.size = object.size ?? "";
		message.seed = object.seed ?? 0;
		return message;
	},
};

function createBaseText2imageResponse(): Text2imageResponse {
	return { result: undefined };
}

export const Text2imageResponse = {
	encode(
		message: Text2imageResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== undefined) {
			File.encode(message.result, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2imageResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imageResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = File.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imageResponse {
		return {
			result: isSet(object.result)
				? File.fromJSON(object.result)
				: undefined,
		};
	},

	toJSON(message: Text2imageResponse): unknown {
		const obj: any = {};
		if (message.result !== undefined) {
			obj.result = File.toJSON(message.result);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imageResponse>, I>>(
		base?: I,
	): Text2imageResponse {
		return Text2imageResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imageResponse>, I>>(
		object: I,
	): Text2imageResponse {
		const message = createBaseText2imageResponse();
		message.result =
			object.result !== undefined && object.result !== null
				? File.fromPartial(object.result)
				: undefined;
		return message;
	},
};

function createBaseCapitalizeRequest(): CapitalizeRequest {
	return { text: "" };
}

export const CapitalizeRequest = {
	encode(
		message: CapitalizeRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.text !== "") {
			writer.uint32(10).string(message.text);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): CapitalizeRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCapitalizeRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.text = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CapitalizeRequest {
		return {
			text: isSet(object.text) ? globalThis.String(object.text) : "",
		};
	},

	toJSON(message: CapitalizeRequest): unknown {
		const obj: any = {};
		if (message.text !== "") {
			obj.text = message.text;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CapitalizeRequest>, I>>(
		base?: I,
	): CapitalizeRequest {
		return CapitalizeRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CapitalizeRequest>, I>>(
		object: I,
	): CapitalizeRequest {
		const message = createBaseCapitalizeRequest();
		message.text = object.text ?? "";
		return message;
	},
};

function createBaseCapitalizeResponse(): CapitalizeResponse {
	return { result: "" };
}

export const CapitalizeResponse = {
	encode(
		message: CapitalizeResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== "") {
			writer.uint32(10).string(message.result);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): CapitalizeResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCapitalizeResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CapitalizeResponse {
		return {
			result: isSet(object.result)
				? globalThis.String(object.result)
				: "",
		};
	},

	toJSON(message: CapitalizeResponse): unknown {
		const obj: any = {};
		if (message.result !== "") {
			obj.result = message.result;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CapitalizeResponse>, I>>(
		base?: I,
	): CapitalizeResponse {
		return CapitalizeResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CapitalizeResponse>, I>>(
		object: I,
	): CapitalizeResponse {
		const message = createBaseCapitalizeResponse();
		message.result = object.result ?? "";
		return message;
	},
};

function createBaseText2textRequest(): Text2textRequest {
	return { roles: [], messages: [], maxTokens: 0 };
}

export const Text2textRequest = {
	encode(
		message: Text2textRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		for (const v of message.roles) {
			writer.uint32(10).string(v!);
		}
		for (const v of message.messages) {
			writer.uint32(18).string(v!);
		}
		if (message.maxTokens !== 0) {
			writer.uint32(24).int32(message.maxTokens);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): Text2textRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2textRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.roles.push(reader.string());
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.messages.push(reader.string());
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.maxTokens = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2textRequest {
		return {
			roles: globalThis.Array.isArray(object?.roles)
				? object.roles.map((e: any) => globalThis.String(e))
				: [],
			messages: globalThis.Array.isArray(object?.messages)
				? object.messages.map((e: any) => globalThis.String(e))
				: [],
			maxTokens: isSet(object.maxTokens)
				? globalThis.Number(object.maxTokens)
				: 0,
		};
	},

	toJSON(message: Text2textRequest): unknown {
		const obj: any = {};
		if (message.roles?.length) {
			obj.roles = message.roles;
		}
		if (message.messages?.length) {
			obj.messages = message.messages;
		}
		if (message.maxTokens !== 0) {
			obj.maxTokens = Math.round(message.maxTokens);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2textRequest>, I>>(
		base?: I,
	): Text2textRequest {
		return Text2textRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2textRequest>, I>>(
		object: I,
	): Text2textRequest {
		const message = createBaseText2textRequest();
		message.roles = object.roles?.map((e) => e) || [];
		message.messages = object.messages?.map((e) => e) || [];
		message.maxTokens = object.maxTokens ?? 0;
		return message;
	},
};

function createBaseText2textResponse(): Text2textResponse {
	return { result: "" };
}

export const Text2textResponse = {
	encode(
		message: Text2textResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== "") {
			writer.uint32(10).string(message.result);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): Text2textResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2textResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2textResponse {
		return {
			result: isSet(object.result)
				? globalThis.String(object.result)
				: "",
		};
	},

	toJSON(message: Text2textResponse): unknown {
		const obj: any = {};
		if (message.result !== "") {
			obj.result = message.result;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2textResponse>, I>>(
		base?: I,
	): Text2textResponse {
		return Text2textResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2textResponse>, I>>(
		object: I,
	): Text2textResponse {
		const message = createBaseText2textResponse();
		message.result = object.result ?? "";
		return message;
	},
};

function createBaseImage2captionRequest(): Image2captionRequest {
	return { image: undefined, tokens: 0, focus: "" };
}

export const Image2captionRequest = {
	encode(
		message: Image2captionRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.image !== undefined) {
			File.encode(message.image, writer.uint32(10).fork()).ldelim();
		}
		if (message.tokens !== 0) {
			writer.uint32(16).int32(message.tokens);
		}
		if (message.focus !== "") {
			writer.uint32(26).string(message.focus);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Image2captionRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseImage2captionRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.image = File.decode(reader, reader.uint32());
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.tokens = reader.int32();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.focus = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Image2captionRequest {
		return {
			image: isSet(object.image)
				? File.fromJSON(object.image)
				: undefined,
			tokens: isSet(object.tokens) ? globalThis.Number(object.tokens) : 0,
			focus: isSet(object.focus) ? globalThis.String(object.focus) : "",
		};
	},

	toJSON(message: Image2captionRequest): unknown {
		const obj: any = {};
		if (message.image !== undefined) {
			obj.image = File.toJSON(message.image);
		}
		if (message.tokens !== 0) {
			obj.tokens = Math.round(message.tokens);
		}
		if (message.focus !== "") {
			obj.focus = message.focus;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Image2captionRequest>, I>>(
		base?: I,
	): Image2captionRequest {
		return Image2captionRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Image2captionRequest>, I>>(
		object: I,
	): Image2captionRequest {
		const message = createBaseImage2captionRequest();
		message.image =
			object.image !== undefined && object.image !== null
				? File.fromPartial(object.image)
				: undefined;
		message.tokens = object.tokens ?? 0;
		message.focus = object.focus ?? "";
		return message;
	},
};

function createBaseImage2captionResponse(): Image2captionResponse {
	return { result: "" };
}

export const Image2captionResponse = {
	encode(
		message: Image2captionResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== "") {
			writer.uint32(10).string(message.result);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Image2captionResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseImage2captionResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Image2captionResponse {
		return {
			result: isSet(object.result)
				? globalThis.String(object.result)
				: "",
		};
	},

	toJSON(message: Image2captionResponse): unknown {
		const obj: any = {};
		if (message.result !== "") {
			obj.result = message.result;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Image2captionResponse>, I>>(
		base?: I,
	): Image2captionResponse {
		return Image2captionResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Image2captionResponse>, I>>(
		object: I,
	): Image2captionResponse {
		const message = createBaseImage2captionResponse();
		message.result = object.result ?? "";
		return message;
	},
};

function createBaseText2audioRequest(): Text2audioRequest {
	return {
		prompt: "",
		negativePrompt: "",
		duration: 0,
		numInferenceSteps: 0,
		numWaveforms: 0,
		seed: 0,
	};
}

export const Text2audioRequest = {
	encode(
		message: Text2audioRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		if (message.negativePrompt !== "") {
			writer.uint32(18).string(message.negativePrompt);
		}
		if (message.duration !== 0) {
			writer.uint32(29).float(message.duration);
		}
		if (message.numInferenceSteps !== 0) {
			writer.uint32(32).int32(message.numInferenceSteps);
		}
		if (message.numWaveforms !== 0) {
			writer.uint32(40).int32(message.numWaveforms);
		}
		if (message.seed !== 0) {
			writer.uint32(48).int32(message.seed);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): Text2audioRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2audioRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.negativePrompt = reader.string();
					continue;
				case 3:
					if (tag !== 29) {
						break;
					}

					message.duration = reader.float();
					continue;
				case 4:
					if (tag !== 32) {
						break;
					}

					message.numInferenceSteps = reader.int32();
					continue;
				case 5:
					if (tag !== 40) {
						break;
					}

					message.numWaveforms = reader.int32();
					continue;
				case 6:
					if (tag !== 48) {
						break;
					}

					message.seed = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2audioRequest {
		return {
			prompt: isSet(object.prompt)
				? globalThis.String(object.prompt)
				: "",
			negativePrompt: isSet(object.negativePrompt)
				? globalThis.String(object.negativePrompt)
				: "",
			duration: isSet(object.duration)
				? globalThis.Number(object.duration)
				: 0,
			numInferenceSteps: isSet(object.numInferenceSteps)
				? globalThis.Number(object.numInferenceSteps)
				: 0,
			numWaveforms: isSet(object.numWaveforms)
				? globalThis.Number(object.numWaveforms)
				: 0,
			seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
		};
	},

	toJSON(message: Text2audioRequest): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		if (message.negativePrompt !== "") {
			obj.negativePrompt = message.negativePrompt;
		}
		if (message.duration !== 0) {
			obj.duration = message.duration;
		}
		if (message.numInferenceSteps !== 0) {
			obj.numInferenceSteps = Math.round(message.numInferenceSteps);
		}
		if (message.numWaveforms !== 0) {
			obj.numWaveforms = Math.round(message.numWaveforms);
		}
		if (message.seed !== 0) {
			obj.seed = Math.round(message.seed);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2audioRequest>, I>>(
		base?: I,
	): Text2audioRequest {
		return Text2audioRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2audioRequest>, I>>(
		object: I,
	): Text2audioRequest {
		const message = createBaseText2audioRequest();
		message.prompt = object.prompt ?? "";
		message.negativePrompt = object.negativePrompt ?? "";
		message.duration = object.duration ?? 0;
		message.numInferenceSteps = object.numInferenceSteps ?? 0;
		message.numWaveforms = object.numWaveforms ?? 0;
		message.seed = object.seed ?? 0;
		return message;
	},
};

function createBaseText2audioResponse(): Text2audioResponse {
	return { result: undefined };
}

export const Text2audioResponse = {
	encode(
		message: Text2audioResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== undefined) {
			File.encode(message.result, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2audioResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2audioResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = File.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2audioResponse {
		return {
			result: isSet(object.result)
				? File.fromJSON(object.result)
				: undefined,
		};
	},

	toJSON(message: Text2audioResponse): unknown {
		const obj: any = {};
		if (message.result !== undefined) {
			obj.result = File.toJSON(message.result);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2audioResponse>, I>>(
		base?: I,
	): Text2audioResponse {
		return Text2audioResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2audioResponse>, I>>(
		object: I,
	): Text2audioResponse {
		const message = createBaseText2audioResponse();
		message.result =
			object.result !== undefined && object.result !== null
				? File.fromPartial(object.result)
				: undefined;
		return message;
	},
};

function createBaseFile2textRequest(): File2textRequest {
	return { file: undefined, maxTokens: 0 };
}

export const File2textRequest = {
	encode(
		message: File2textRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.file !== undefined) {
			File.encode(message.file, writer.uint32(10).fork()).ldelim();
		}
		if (message.maxTokens !== 0) {
			writer.uint32(16).int32(message.maxTokens);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): File2textRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFile2textRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.file = File.decode(reader, reader.uint32());
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.maxTokens = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): File2textRequest {
		return {
			file: isSet(object.file) ? File.fromJSON(object.file) : undefined,
			maxTokens: isSet(object.maxTokens)
				? globalThis.Number(object.maxTokens)
				: 0,
		};
	},

	toJSON(message: File2textRequest): unknown {
		const obj: any = {};
		if (message.file !== undefined) {
			obj.file = File.toJSON(message.file);
		}
		if (message.maxTokens !== 0) {
			obj.maxTokens = Math.round(message.maxTokens);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<File2textRequest>, I>>(
		base?: I,
	): File2textRequest {
		return File2textRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<File2textRequest>, I>>(
		object: I,
	): File2textRequest {
		const message = createBaseFile2textRequest();
		message.file =
			object.file !== undefined && object.file !== null
				? File.fromPartial(object.file)
				: undefined;
		message.maxTokens = object.maxTokens ?? 0;
		return message;
	},
};

function createBaseFile2textResponse(): File2textResponse {
	return { result: "" };
}

export const File2textResponse = {
	encode(
		message: File2textResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== "") {
			writer.uint32(10).string(message.result);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): File2textResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFile2textResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): File2textResponse {
		return {
			result: isSet(object.result)
				? globalThis.String(object.result)
				: "",
		};
	},

	toJSON(message: File2textResponse): unknown {
		const obj: any = {};
		if (message.result !== "") {
			obj.result = message.result;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<File2textResponse>, I>>(
		base?: I,
	): File2textResponse {
		return File2textResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<File2textResponse>, I>>(
		object: I,
	): File2textResponse {
		const message = createBaseFile2textResponse();
		message.result = object.result ?? "";
		return message;
	},
};

function createBaseText2promptRequest(): Text2promptRequest {
	return { prompt: "", maxNewTokens: 0 };
}

export const Text2promptRequest = {
	encode(
		message: Text2promptRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		if (message.maxNewTokens !== 0) {
			writer.uint32(16).int32(message.maxNewTokens);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2promptRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2promptRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.maxNewTokens = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2promptRequest {
		return {
			prompt: isSet(object.prompt)
				? globalThis.String(object.prompt)
				: "",
			maxNewTokens: isSet(object.maxNewTokens)
				? globalThis.Number(object.maxNewTokens)
				: 0,
		};
	},

	toJSON(message: Text2promptRequest): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		if (message.maxNewTokens !== 0) {
			obj.maxNewTokens = Math.round(message.maxNewTokens);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2promptRequest>, I>>(
		base?: I,
	): Text2promptRequest {
		return Text2promptRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2promptRequest>, I>>(
		object: I,
	): Text2promptRequest {
		const message = createBaseText2promptRequest();
		message.prompt = object.prompt ?? "";
		message.maxNewTokens = object.maxNewTokens ?? 0;
		return message;
	},
};

function createBaseText2promptResponse(): Text2promptResponse {
	return { result: "" };
}

export const Text2promptResponse = {
	encode(
		message: Text2promptResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== "") {
			writer.uint32(10).string(message.result);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2promptResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2promptResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2promptResponse {
		return {
			result: isSet(object.result)
				? globalThis.String(object.result)
				: "",
		};
	},

	toJSON(message: Text2promptResponse): unknown {
		const obj: any = {};
		if (message.result !== "") {
			obj.result = message.result;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2promptResponse>, I>>(
		base?: I,
	): Text2promptResponse {
		return Text2promptResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2promptResponse>, I>>(
		object: I,
	): Text2promptResponse {
		const message = createBaseText2promptResponse();
		message.result = object.result ?? "";
		return message;
	},
};

function createBaseTurboeditRequest(): TurboeditRequest {
	return {
		inputImage: undefined,
		srcPrompt: "",
		tgtPrompt: "",
		seed: 0,
		w1: 0,
	};
}

export const TurboeditRequest = {
	encode(
		message: TurboeditRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.inputImage !== undefined) {
			File.encode(message.inputImage, writer.uint32(10).fork()).ldelim();
		}
		if (message.srcPrompt !== "") {
			writer.uint32(18).string(message.srcPrompt);
		}
		if (message.tgtPrompt !== "") {
			writer.uint32(26).string(message.tgtPrompt);
		}
		if (message.seed !== 0) {
			writer.uint32(32).int32(message.seed);
		}
		if (message.w1 !== 0) {
			writer.uint32(45).float(message.w1);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): TurboeditRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTurboeditRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.inputImage = File.decode(reader, reader.uint32());
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.srcPrompt = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.tgtPrompt = reader.string();
					continue;
				case 4:
					if (tag !== 32) {
						break;
					}

					message.seed = reader.int32();
					continue;
				case 5:
					if (tag !== 45) {
						break;
					}

					message.w1 = reader.float();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TurboeditRequest {
		return {
			inputImage: isSet(object.inputImage)
				? File.fromJSON(object.inputImage)
				: undefined,
			srcPrompt: isSet(object.srcPrompt)
				? globalThis.String(object.srcPrompt)
				: "",
			tgtPrompt: isSet(object.tgtPrompt)
				? globalThis.String(object.tgtPrompt)
				: "",
			seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
			w1: isSet(object.w1) ? globalThis.Number(object.w1) : 0,
		};
	},

	toJSON(message: TurboeditRequest): unknown {
		const obj: any = {};
		if (message.inputImage !== undefined) {
			obj.inputImage = File.toJSON(message.inputImage);
		}
		if (message.srcPrompt !== "") {
			obj.srcPrompt = message.srcPrompt;
		}
		if (message.tgtPrompt !== "") {
			obj.tgtPrompt = message.tgtPrompt;
		}
		if (message.seed !== 0) {
			obj.seed = Math.round(message.seed);
		}
		if (message.w1 !== 0) {
			obj.w1 = message.w1;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TurboeditRequest>, I>>(
		base?: I,
	): TurboeditRequest {
		return TurboeditRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TurboeditRequest>, I>>(
		object: I,
	): TurboeditRequest {
		const message = createBaseTurboeditRequest();
		message.inputImage =
			object.inputImage !== undefined && object.inputImage !== null
				? File.fromPartial(object.inputImage)
				: undefined;
		message.srcPrompt = object.srcPrompt ?? "";
		message.tgtPrompt = object.tgtPrompt ?? "";
		message.seed = object.seed ?? 0;
		message.w1 = object.w1 ?? 0;
		return message;
	},
};

function createBaseTurboeditResponse(): TurboeditResponse {
	return { result: undefined };
}

export const TurboeditResponse = {
	encode(
		message: TurboeditResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== undefined) {
			File.encode(message.result, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): TurboeditResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTurboeditResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = File.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TurboeditResponse {
		return {
			result: isSet(object.result)
				? File.fromJSON(object.result)
				: undefined,
		};
	},

	toJSON(message: TurboeditResponse): unknown {
		const obj: any = {};
		if (message.result !== undefined) {
			obj.result = File.toJSON(message.result);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TurboeditResponse>, I>>(
		base?: I,
	): TurboeditResponse {
		return TurboeditResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TurboeditResponse>, I>>(
		object: I,
	): TurboeditResponse {
		const message = createBaseTurboeditResponse();
		message.result =
			object.result !== undefined && object.result !== null
				? File.fromPartial(object.result)
				: undefined;
		return message;
	},
};

function createBaseText2imagefileRequest(): Text2imagefileRequest {
	return { prompt: "" };
}

export const Text2imagefileRequest = {
	encode(
		message: Text2imagefileRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2imagefileRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imagefileRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imagefileRequest {
		return {
			prompt: isSet(object.prompt)
				? globalThis.String(object.prompt)
				: "",
		};
	},

	toJSON(message: Text2imagefileRequest): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imagefileRequest>, I>>(
		base?: I,
	): Text2imagefileRequest {
		return Text2imagefileRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imagefileRequest>, I>>(
		object: I,
	): Text2imagefileRequest {
		const message = createBaseText2imagefileRequest();
		message.prompt = object.prompt ?? "";
		return message;
	},
};

function createBaseText2imagefileResponse(): Text2imagefileResponse {
	return { result: undefined };
}

export const Text2imagefileResponse = {
	encode(
		message: Text2imagefileResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.result !== undefined) {
			File.encode(message.result, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(
		input: _m0.Reader | Uint8Array,
		length?: number,
	): Text2imagefileResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseText2imagefileResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.result = File.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Text2imagefileResponse {
		return {
			result: isSet(object.result)
				? File.fromJSON(object.result)
				: undefined,
		};
	},

	toJSON(message: Text2imagefileResponse): unknown {
		const obj: any = {};
		if (message.result !== undefined) {
			obj.result = File.toJSON(message.result);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Text2imagefileResponse>, I>>(
		base?: I,
	): Text2imagefileResponse {
		return Text2imagefileResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Text2imagefileResponse>, I>>(
		object: I,
	): Text2imagefileResponse {
		const message = createBaseText2imagefileResponse();
		message.result =
			object.result !== undefined && object.result !== null
				? File.fromPartial(object.result)
				: undefined;
		return message;
	},
};

function createBaseTaskRequest(): TaskRequest {
	return {
		text2imagedraft: undefined,
		text2image: undefined,
		capitalize: undefined,
		text2text: undefined,
		image2caption: undefined,
		text2audio: undefined,
		file2text: undefined,
		text2prompt: undefined,
		turboedit: undefined,
		text2imagefile: undefined,
	};
}

export const TaskRequest = {
	encode(
		message: TaskRequest,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.text2imagedraft !== undefined) {
			Text2imagedraftRequest.encode(
				message.text2imagedraft,
				writer.uint32(10).fork(),
			).ldelim();
		}
		if (message.text2image !== undefined) {
			Text2imageRequest.encode(
				message.text2image,
				writer.uint32(18).fork(),
			).ldelim();
		}
		if (message.capitalize !== undefined) {
			CapitalizeRequest.encode(
				message.capitalize,
				writer.uint32(26).fork(),
			).ldelim();
		}
		if (message.text2text !== undefined) {
			Text2textRequest.encode(
				message.text2text,
				writer.uint32(34).fork(),
			).ldelim();
		}
		if (message.image2caption !== undefined) {
			Image2captionRequest.encode(
				message.image2caption,
				writer.uint32(42).fork(),
			).ldelim();
		}
		if (message.text2audio !== undefined) {
			Text2audioRequest.encode(
				message.text2audio,
				writer.uint32(50).fork(),
			).ldelim();
		}
		if (message.file2text !== undefined) {
			File2textRequest.encode(
				message.file2text,
				writer.uint32(58).fork(),
			).ldelim();
		}
		if (message.text2prompt !== undefined) {
			Text2promptRequest.encode(
				message.text2prompt,
				writer.uint32(66).fork(),
			).ldelim();
		}
		if (message.turboedit !== undefined) {
			TurboeditRequest.encode(
				message.turboedit,
				writer.uint32(74).fork(),
			).ldelim();
		}
		if (message.text2imagefile !== undefined) {
			Text2imagefileRequest.encode(
				message.text2imagefile,
				writer.uint32(82).fork(),
			).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): TaskRequest {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.text2imagedraft = Text2imagedraftRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.text2image = Text2imageRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.capitalize = CapitalizeRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.text2text = Text2textRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.image2caption = Image2captionRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.text2audio = Text2audioRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.file2text = File2textRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 8:
					if (tag !== 66) {
						break;
					}

					message.text2prompt = Text2promptRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 9:
					if (tag !== 74) {
						break;
					}

					message.turboedit = TurboeditRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 10:
					if (tag !== 82) {
						break;
					}

					message.text2imagefile = Text2imagefileRequest.decode(
						reader,
						reader.uint32(),
					);
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskRequest {
		return {
			text2imagedraft: isSet(object.text2imagedraft)
				? Text2imagedraftRequest.fromJSON(object.text2imagedraft)
				: undefined,
			text2image: isSet(object.text2image)
				? Text2imageRequest.fromJSON(object.text2image)
				: undefined,
			capitalize: isSet(object.capitalize)
				? CapitalizeRequest.fromJSON(object.capitalize)
				: undefined,
			text2text: isSet(object.text2text)
				? Text2textRequest.fromJSON(object.text2text)
				: undefined,
			image2caption: isSet(object.image2caption)
				? Image2captionRequest.fromJSON(object.image2caption)
				: undefined,
			text2audio: isSet(object.text2audio)
				? Text2audioRequest.fromJSON(object.text2audio)
				: undefined,
			file2text: isSet(object.file2text)
				? File2textRequest.fromJSON(object.file2text)
				: undefined,
			text2prompt: isSet(object.text2prompt)
				? Text2promptRequest.fromJSON(object.text2prompt)
				: undefined,
			turboedit: isSet(object.turboedit)
				? TurboeditRequest.fromJSON(object.turboedit)
				: undefined,
			text2imagefile: isSet(object.text2imagefile)
				? Text2imagefileRequest.fromJSON(object.text2imagefile)
				: undefined,
		};
	},

	toJSON(message: TaskRequest): unknown {
		const obj: any = {};
		if (message.text2imagedraft !== undefined) {
			obj.text2imagedraft = Text2imagedraftRequest.toJSON(
				message.text2imagedraft,
			);
		}
		if (message.text2image !== undefined) {
			obj.text2image = Text2imageRequest.toJSON(message.text2image);
		}
		if (message.capitalize !== undefined) {
			obj.capitalize = CapitalizeRequest.toJSON(message.capitalize);
		}
		if (message.text2text !== undefined) {
			obj.text2text = Text2textRequest.toJSON(message.text2text);
		}
		if (message.image2caption !== undefined) {
			obj.image2caption = Image2captionRequest.toJSON(
				message.image2caption,
			);
		}
		if (message.text2audio !== undefined) {
			obj.text2audio = Text2audioRequest.toJSON(message.text2audio);
		}
		if (message.file2text !== undefined) {
			obj.file2text = File2textRequest.toJSON(message.file2text);
		}
		if (message.text2prompt !== undefined) {
			obj.text2prompt = Text2promptRequest.toJSON(message.text2prompt);
		}
		if (message.turboedit !== undefined) {
			obj.turboedit = TurboeditRequest.toJSON(message.turboedit);
		}
		if (message.text2imagefile !== undefined) {
			obj.text2imagefile = Text2imagefileRequest.toJSON(
				message.text2imagefile,
			);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskRequest>, I>>(
		base?: I,
	): TaskRequest {
		return TaskRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskRequest>, I>>(
		object: I,
	): TaskRequest {
		const message = createBaseTaskRequest();
		message.text2imagedraft =
			object.text2imagedraft !== undefined &&
			object.text2imagedraft !== null
				? Text2imagedraftRequest.fromPartial(object.text2imagedraft)
				: undefined;
		message.text2image =
			object.text2image !== undefined && object.text2image !== null
				? Text2imageRequest.fromPartial(object.text2image)
				: undefined;
		message.capitalize =
			object.capitalize !== undefined && object.capitalize !== null
				? CapitalizeRequest.fromPartial(object.capitalize)
				: undefined;
		message.text2text =
			object.text2text !== undefined && object.text2text !== null
				? Text2textRequest.fromPartial(object.text2text)
				: undefined;
		message.image2caption =
			object.image2caption !== undefined && object.image2caption !== null
				? Image2captionRequest.fromPartial(object.image2caption)
				: undefined;
		message.text2audio =
			object.text2audio !== undefined && object.text2audio !== null
				? Text2audioRequest.fromPartial(object.text2audio)
				: undefined;
		message.file2text =
			object.file2text !== undefined && object.file2text !== null
				? File2textRequest.fromPartial(object.file2text)
				: undefined;
		message.text2prompt =
			object.text2prompt !== undefined && object.text2prompt !== null
				? Text2promptRequest.fromPartial(object.text2prompt)
				: undefined;
		message.turboedit =
			object.turboedit !== undefined && object.turboedit !== null
				? TurboeditRequest.fromPartial(object.turboedit)
				: undefined;
		message.text2imagefile =
			object.text2imagefile !== undefined &&
			object.text2imagefile !== null
				? Text2imagefileRequest.fromPartial(object.text2imagefile)
				: undefined;
		return message;
	},
};

function createBaseTaskResponse(): TaskResponse {
	return {
		text2imagedraft: undefined,
		text2image: undefined,
		capitalize: undefined,
		text2text: undefined,
		image2caption: undefined,
		text2audio: undefined,
		file2text: undefined,
		text2prompt: undefined,
		turboedit: undefined,
		text2imagefile: undefined,
	};
}

export const TaskResponse = {
	encode(
		message: TaskResponse,
		writer: _m0.Writer = _m0.Writer.create(),
	): _m0.Writer {
		if (message.text2imagedraft !== undefined) {
			Text2imagedraftResponse.encode(
				message.text2imagedraft,
				writer.uint32(10).fork(),
			).ldelim();
		}
		if (message.text2image !== undefined) {
			Text2imageResponse.encode(
				message.text2image,
				writer.uint32(18).fork(),
			).ldelim();
		}
		if (message.capitalize !== undefined) {
			CapitalizeResponse.encode(
				message.capitalize,
				writer.uint32(26).fork(),
			).ldelim();
		}
		if (message.text2text !== undefined) {
			Text2textResponse.encode(
				message.text2text,
				writer.uint32(34).fork(),
			).ldelim();
		}
		if (message.image2caption !== undefined) {
			Image2captionResponse.encode(
				message.image2caption,
				writer.uint32(42).fork(),
			).ldelim();
		}
		if (message.text2audio !== undefined) {
			Text2audioResponse.encode(
				message.text2audio,
				writer.uint32(50).fork(),
			).ldelim();
		}
		if (message.file2text !== undefined) {
			File2textResponse.encode(
				message.file2text,
				writer.uint32(58).fork(),
			).ldelim();
		}
		if (message.text2prompt !== undefined) {
			Text2promptResponse.encode(
				message.text2prompt,
				writer.uint32(66).fork(),
			).ldelim();
		}
		if (message.turboedit !== undefined) {
			TurboeditResponse.encode(
				message.turboedit,
				writer.uint32(74).fork(),
			).ldelim();
		}
		if (message.text2imagefile !== undefined) {
			Text2imagefileResponse.encode(
				message.text2imagefile,
				writer.uint32(82).fork(),
			).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): TaskResponse {
		const reader =
			input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.text2imagedraft = Text2imagedraftResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.text2image = Text2imageResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.capitalize = CapitalizeResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.text2text = Text2textResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.image2caption = Image2captionResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.text2audio = Text2audioResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.file2text = File2textResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 8:
					if (tag !== 66) {
						break;
					}

					message.text2prompt = Text2promptResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 9:
					if (tag !== 74) {
						break;
					}

					message.turboedit = TurboeditResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
				case 10:
					if (tag !== 82) {
						break;
					}

					message.text2imagefile = Text2imagefileResponse.decode(
						reader,
						reader.uint32(),
					);
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskResponse {
		return {
			text2imagedraft: isSet(object.text2imagedraft)
				? Text2imagedraftResponse.fromJSON(object.text2imagedraft)
				: undefined,
			text2image: isSet(object.text2image)
				? Text2imageResponse.fromJSON(object.text2image)
				: undefined,
			capitalize: isSet(object.capitalize)
				? CapitalizeResponse.fromJSON(object.capitalize)
				: undefined,
			text2text: isSet(object.text2text)
				? Text2textResponse.fromJSON(object.text2text)
				: undefined,
			image2caption: isSet(object.image2caption)
				? Image2captionResponse.fromJSON(object.image2caption)
				: undefined,
			text2audio: isSet(object.text2audio)
				? Text2audioResponse.fromJSON(object.text2audio)
				: undefined,
			file2text: isSet(object.file2text)
				? File2textResponse.fromJSON(object.file2text)
				: undefined,
			text2prompt: isSet(object.text2prompt)
				? Text2promptResponse.fromJSON(object.text2prompt)
				: undefined,
			turboedit: isSet(object.turboedit)
				? TurboeditResponse.fromJSON(object.turboedit)
				: undefined,
			text2imagefile: isSet(object.text2imagefile)
				? Text2imagefileResponse.fromJSON(object.text2imagefile)
				: undefined,
		};
	},

	toJSON(message: TaskResponse): unknown {
		const obj: any = {};
		if (message.text2imagedraft !== undefined) {
			obj.text2imagedraft = Text2imagedraftResponse.toJSON(
				message.text2imagedraft,
			);
		}
		if (message.text2image !== undefined) {
			obj.text2image = Text2imageResponse.toJSON(message.text2image);
		}
		if (message.capitalize !== undefined) {
			obj.capitalize = CapitalizeResponse.toJSON(message.capitalize);
		}
		if (message.text2text !== undefined) {
			obj.text2text = Text2textResponse.toJSON(message.text2text);
		}
		if (message.image2caption !== undefined) {
			obj.image2caption = Image2captionResponse.toJSON(
				message.image2caption,
			);
		}
		if (message.text2audio !== undefined) {
			obj.text2audio = Text2audioResponse.toJSON(message.text2audio);
		}
		if (message.file2text !== undefined) {
			obj.file2text = File2textResponse.toJSON(message.file2text);
		}
		if (message.text2prompt !== undefined) {
			obj.text2prompt = Text2promptResponse.toJSON(message.text2prompt);
		}
		if (message.turboedit !== undefined) {
			obj.turboedit = TurboeditResponse.toJSON(message.turboedit);
		}
		if (message.text2imagefile !== undefined) {
			obj.text2imagefile = Text2imagefileResponse.toJSON(
				message.text2imagefile,
			);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskResponse>, I>>(
		base?: I,
	): TaskResponse {
		return TaskResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskResponse>, I>>(
		object: I,
	): TaskResponse {
		const message = createBaseTaskResponse();
		message.text2imagedraft =
			object.text2imagedraft !== undefined &&
			object.text2imagedraft !== null
				? Text2imagedraftResponse.fromPartial(object.text2imagedraft)
				: undefined;
		message.text2image =
			object.text2image !== undefined && object.text2image !== null
				? Text2imageResponse.fromPartial(object.text2image)
				: undefined;
		message.capitalize =
			object.capitalize !== undefined && object.capitalize !== null
				? CapitalizeResponse.fromPartial(object.capitalize)
				: undefined;
		message.text2text =
			object.text2text !== undefined && object.text2text !== null
				? Text2textResponse.fromPartial(object.text2text)
				: undefined;
		message.image2caption =
			object.image2caption !== undefined && object.image2caption !== null
				? Image2captionResponse.fromPartial(object.image2caption)
				: undefined;
		message.text2audio =
			object.text2audio !== undefined && object.text2audio !== null
				? Text2audioResponse.fromPartial(object.text2audio)
				: undefined;
		message.file2text =
			object.file2text !== undefined && object.file2text !== null
				? File2textResponse.fromPartial(object.file2text)
				: undefined;
		message.text2prompt =
			object.text2prompt !== undefined && object.text2prompt !== null
				? Text2promptResponse.fromPartial(object.text2prompt)
				: undefined;
		message.turboedit =
			object.turboedit !== undefined && object.turboedit !== null
				? TurboeditResponse.fromPartial(object.turboedit)
				: undefined;
		message.text2imagefile =
			object.text2imagefile !== undefined &&
			object.text2imagefile !== null
				? Text2imagefileResponse.fromPartial(object.text2imagefile)
				: undefined;
		return message;
	},
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}
